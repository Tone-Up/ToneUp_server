# ToneUp_server
# **프로젝트**

### tone-up

프로젝트 기간/ 인원

2025.05. ~

FE 1명, BE 1명

프로젝트 내용

퍼스널 컬러 분석을 통한 개개인 맞춤형 상품 추천 및 sns 서비스 

### 외부 서버 호출 시 스레드 부하 문제 해결

- **상황**: 퍼스널 컬러 분석을 위해 FastAPI 기반의 외부 서버에 요청을 보내야 했습니다.
- **문제**: `RestTemplate`을 사용할 경우 동기 방식으로 인해 스레드 점유가 심해지고, 서비스 부하가 증가했습니다.
- **행동**: `WebClient`를 도입하여 비동기 방식으로 처리되도록 개선했습니다.
- **결과**: 스레드 수요가 줄어들고, 전체 요청 처리 속도가 개선되어 안정적인 외부 연동이 가능해졌습니다.

---

### 첫 요청 딜레이 해결

- **상황**: 서비스 배포 후 첫 요청에서 응답 속도가 비정상적으로 느려지는 문제가 있었습니다.
- **문제**: JVM 초기 구동 시 JIT 컴파일과 클래스 로딩 등의 이슈로 웜업 시간이 필요했습니다.
- **행동**: 배포 후 내부에서 미리 더미 요청을 보내는 웜업 로직을 추가했습니다.
- **결과**: 사용자 기준 첫 요청 응답 속도가 정상화되었고, 체감 품질이 개선되었습니다.

---

### 유지보수성과 확장성을 고려한 인증 시스템 설계

- **상황**: 소셜 로그인 기능을 구현해야 했고, 단순히 Google만이 아닌 다른 플랫폼도 확장 고려가 필요했습니다.
- **문제**: 추후 유지보수 및 확장을 고려한 설계가 요구되었습니다.
- **행동**: 전략 패턴, 템플릿 메서드 패턴, 팩토리 패턴을 적용하여 OOP 원칙에 맞게 인증 로직을 분리하였고, `@ControllerAdvice`를 이용해 예외 처리도 일관되게 구성했습니다.
- **결과**: 새로운 플랫폼 추가 시에도 기존 코드를 건드리지 않고 기능을 확장할 수 있는 구조를 완성했습니다.

---

### 좋아요 기능의 동시성 문제 대응

- **상황**: 다수의 사용자가 동시에 좋아요를 누를 수 있는 기능이 필요했습니다.
- **문제**: 동시 요청 처리 시 Race Condition으로 인해 데이터 정합성이 깨질 수 있었습니다.
- **행동**: 분산 락(Mutex)을 적용하고, 실패 시 재시도 로직을 도입하여 안정적인 처리 흐름을 보장했습니다.
- **결과**: 좋아요 수가 정확히 반영되며, 동시성 이슈 없이 일관성 있는 데이터가 유지되었습니다.

---

### 실시간 채팅 서버 구현

- **상황**: 사용자 간 실시간 채팅 기능이 요구되었습니다.
- **문제**: 안정적인 연결과 이벤트 기반 처리가 필요했습니다.
- **행동**: `Netty-SocketIO` 기반 서버를 구축하고, 커스텀 어노테이션을 통해 이벤트 핸들링 구조를 설계했습니다.
- **결과**: 안정적인 실시간 채팅 기능을 완성하여 사용자 경험을 강화했습니다.

---

### 퍼스널 컬러 분석 모델 개발

- **상황**: 이미지 기반으로 사용자의 퍼스널 컬러를 분석하는 기능이 필요했습니다.
- **행동**: 이미지 분석을 통해 얼굴 추출 후 명도와 채도 추출 후 퍼스널컬러 분석, 이를 FastAPI로 배포하여 Spring 서버에서 호출 가능한 형태로 구성했습니다.
- **결과**: 사용자 셀카 기반으로 컬러 분석 결과를 제공할 수 있게 되었습니다.

---

### 서버 리소스 효율화를 위한 Presigned URL 적용

- **상황**: 이미지 업로드 시 서버에 리소스가 집중되는 문제가 있었습니다.
- **행동**: AWS S3의 Presigned URL을 이용하여 클라이언트에서 직접 업로드하도록 변경했습니다.
- **결과**: 서버 트래픽을 줄이고, 이미지 처리 속도를 개선했습니다.

---

### 무중단 배포 구현

- **상황**: 서비스 특성상 실시간성 유지가 중요해, 배포 중에도 서비스 중단이 발생하지 않아야 했습니다.
- **문제**: 기존에는 배포 중 연결 끊김이 발생했습니다.
- **행동**: 무중단 배포 전략(Health Check + Blue-Green 방식)을 적용하고, 배포 작업의 병렬처리를 통해 배포 속도도 개선했습니다.
- **결과**: 무중단 배포를 실현하고, 배포 시간은 약 40% 단축되었습니다.

---

### 테스트 및 API 문서화

- **상황**: 개발된 API의 신뢰성과 활용도를 높이기 위한 품질 관리가 필요했습니다.
- **행동**: 테스트 커버리지 확보를 위한 단위 테스트 작성과 함께 Swagger를 활용한 API 문서화도 병행했습니다.
- **결과**: 팀 내 협업과 프론트엔드 연동 효율이 높아졌고, 운영 중 오류 발생 가능성을 낮출 수 있었습니다.
